/*
 * ASearch.h
 *
 *  Created on: Sep 21, 2017
 *      Author: adilhamidmalla
 */

#ifndef ASEARCH_H_
#define ASEARCH_H_

#include <queue>
#include <vector>
#include <algorithm>
#include <iostream>

#include "Node.h"
#include "Action.h"
#include "CompareClassNode.h"
#include "State.h"

using namespace std;

template<class ProblemState> class ASearch {

public:

	enum {
		STATE_INVALID, STATE_SEARCHING, STATE_GOAL, STATE_NOTINIT, STATE_FAIL

	};

// Member Variables First
	int countSteps;
	int currStateVal;
	int depthOfSearch;

//Start State
	Node * startNode;
// Goal State
	Node * goalNode;
// Current State
	Node * currentNode;
// Frontier of the A Star
	std::vector<Node*> frontier;

// Successors
	std::vector<Node *> successors;
	std::vector<Node *> exploredSet;

//To calculate the number of nodes generated by the Search Algorithm
	int nodeCount;

// Constructor
	ASearch():
		currStateVal(STATE_NOTINIT),
		startNode(NULL),
		goalNode(NULL),
		currentNode(NULL),
		countSteps(0),
		nodeCount(0),
		depthOfSearch(0)
	{
	}

// Functions
	/***
	 * Initializes the problem by using the start and goal state.
	 */
	void setInitStateGoalState(ProblemState &startState,
			ProblemState& goalState) {

		startNode = initializeNode();
		goalNode = initializeNode();

		startNode->currentState = startState;
		goalNode->currentState = goalState;

		currStateVal = STATE_SEARCHING;

		//Now Initialize the cost Values of the Nodes accordingly

		startNode->gCost = 0.0;
		startNode->hCost = startNode->currentState.HeuristicsEstimateCost(
				goalNode->currentState);
		startNode->totalCost = startNode->gCost + startNode->hCost;
		startNode->Parent = NULL;

		//Now we update the frontier since we have explored the initial or goal node
		frontier.push_back(startNode);
		push_heap(frontier.begin(), frontier.end(), CompareClassNode()); // Heapify the Vector

		//Initialize the step count for how many steps you have taken
		countSteps = 0;
		depthOfSearch = 0;

	}

	/***
	 * Adding a successor node to the start or current Node while checking the frontier
	 */
	bool AddSuccessor(ProblemState &presentState) {
		Node * newNode = initializeNode();
		if (!newNode) {
			return false;
		}
		newNode->currentState = presentState;
		successors.push_back(newNode);
		return true;
	}

	Node * initializeNode() {
		Node * newNode = new Node();
		nodeCount++;
		return newNode;
	}

	void deleteNode(Node * node) {
		nodeCount--;
		delete node;
	}
	/***
	 * Deleting the Nodes which are in frontier or exploredSet
	 */
	void deleteProcessedNodes() {
		//Delete frontier
		for (auto val : frontier) {
			Node * temp = val;
			deleteNode(temp);
		}
		frontier.clear();
		//Delete the closeList of Nodes
		for (auto val : exploredSet) {
			Node * temp = val;
			deleteNode(temp);
		}
		exploredSet.clear();
		//Delete the goal Node
		deleteNode(goalNode);
	}

	/***
	 * Deleting the Nodes which are not in frontier or exploredSet but generated using the successors
	 */
	void deleteUnProcessedNodes() {
		// Implement this function and check that you are having right things present
	}

	unsigned int initAsearch() {
		//Initial Conditions needs to be updated

		std::cout<< "Here i am "<<std::endl;

		// If goal node has been achieved already
		if (currStateVal == STATE_GOAL || currStateVal == STATE_FAIL)
			return currStateVal;

		// Checking if their is any Node left in frontier: if no then  return the goal is not achievable
		if (frontier.empty()) {
			deleteProcessedNodes();
			currStateVal = STATE_FAIL;
			return currStateVal;
		}

		// If frontier is not empty then we add the steps
		countSteps++;

		//Now Get the best Node from the frontier
		Node * nodePop = frontier.front();
		pop_heap(frontier.begin(), frontier.end(), CompareClassNode());
		frontier.pop_back();

		// Goal test the node popped from frontier
		if (nodePop->currentState.IsGoalNode(goalNode->currentState)) {
			goalNode->Parent = nodePop->Parent;
			goalNode->totalCost = nodePop->totalCost;
			goalNode->gCost = nodePop->gCost;
			goalNode->hCost = nodePop->hCost;

			// Special Case of whether the goal present is start goal
			// Where to handle the same ??? No Idea

			currStateVal = STATE_GOAL;
			return currStateVal;

		} else {  // Not Goal State then explore the more branches of the node

			successors.clear();

//			bool returnVal = nodePop->currentState.GenerateSuccessor(successors,
//					nodePop ? &nodePop->Parent->currentState : NULL);

			std::vector<State> returnedSuccessors = nodePop->currentState.GenerateSuccessors(nodePop->Parent->currentState);

			//Add the successors to the list
			for(auto val :returnedSuccessors){
				AddSuccessor(val);
			}

			if (successors.empty()) { // If the successors were not generated due to memory issue or some other issue

				std::cout << "Am i doing it right or wrong"<<std::endl;

				for (auto iter = successors.begin(); iter != successors.end();
						iter++) {
					deleteNode(*iter);
				}

				successors.clear();

				currStateVal = STATE_FAIL;
				std::cout << "Ran out of Memory : Successor Fault" << std::endl;
				return currStateVal;

			}

			// Handling the case where the node has successors

			for (auto successorIter = successors.begin();
					successorIter != successors.end(); successorIter++) {

				float updatedGCost = nodePop->gCost
						+ nodePop->currentState.GetGCost(
								(*successorIter)->currentState); // Get Cost will be user dependent

						// Checking the frontier
				auto frontierIter = frontier.begin();
				for (; frontierIter != frontier.end(); frontierIter++) {
					if ((*frontierIter)->currentState.IsIdenticalState(
							(*successorIter)->currentState)) {
						break;
					}
				}
				if (frontierIter != frontier.end()) {
					if ((*frontierIter)->gCost <= updatedGCost) {
						deleteNode(*successorIter);
						continue;
					}
				}

				//Checking the Explored Nodes
				auto exploredIter = exploredSet.begin();
				for (; exploredIter != exploredSet.end(); frontierIter++) {
					if ((*exploredIter)->currentState.IsIdenticalState(
							(*successorIter)->currentState)) {
						break;
					}
				}
				if (exploredIter != exploredSet.end()) {
					if ((*exploredIter)->gCost <= updatedGCost) {
						deleteNode(*successorIter);
						continue;
					}
				}
				// End of Checking the already present states

				(*successorIter)->Parent = nodePop;
				(*successorIter)->gCost = updatedGCost;
				(*successorIter)->hCost =
						(*successorIter)->currentState.HeuristicsEstimateCost(
								goalNode->currentState);
				(*successorIter)->totalCost = (*successorIter)->gCost
						+ (*successorIter)->hCost;

				// Remove from explored Node as it is visited again and updated
				if (exploredIter != exploredSet.end()) {
					deleteNode((*exploredIter));
					exploredSet.erase(exploredIter);
				}

				// If the node is present in the frontier also then we need to update the same
				if (frontierIter != frontier.end()) {
					deleteNode((*frontierIter));
					frontier.erase(frontierIter);

					make_heap(frontier.begin(), frontier.end(),
							CompareClassNode()); // Heapify on invalid heap doesn't work
				}

				frontier.push_back((*successorIter));

				push_heap(frontier.begin(), frontier.end(), CompareClassNode());

			}

			exploredSet.push_back(nodePop);

		}

		return currStateVal;
	}

	// Solution Path From the Algorithm

	ProblemState * GetStartSolutionState(){
		currentNode = startNode;
		if(startNode){
			return &startNode->currentState;
		}
		return NULL;
	}

	// Getting the Next Solution Node and State for full traversal

	ProblemState * GetNextSolutionState(){
		if(currentNode){
			if(currentNode->child){
				Node *childNode = currentNode->child;
				currentNode = currentNode->child;
				return &childNode->currentState;
			}
		}
		return NULL;
	}

	ProblemState * GetSolutionEndState(){
		currentNode = goalNode;
		if(goalNode){
			return &goalNode->currentState;
		}
		return NULL;
	}

	// Getting the solution from traversing from backward

	ProblemState * GetSolutionPrevNode(){
		if(currentNode){
			if(currentNode->Parent){
				Node * parentNode = currentNode->Parent;
				currentNode = currentNode->Parent;
				return &parentNode->currentState;
			}
		}
		return NULL;
	}


	//Total Cost for the Solution

	float GetTotalSolutionCost(){
		if(goalNode && currStateVal == STATE_GOAL){
			return goalNode->gCost; // return actual cost to reach the goal == totalCost == gCost + 0
		}
		return -1;
	}

};

#endif /* ASEARCH_H_ */

