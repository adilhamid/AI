/*
 * ASearch.h
 *
 *  Created on: Sep 21, 2017
 *      Author: adilhamidmalla
 */

#ifndef ASEARCH_H_
#define ASEARCH_H_

#include <queue>
#include <vector>

template<class ProblemState> class ASearch {

	enum {
		STATE_INVALID, STATE_SEARCHING, STATE_GOAL, STATE_NOTINIT, STATE_FAIL

	};

// Member Variables First
	int countSteps;
	int currStateVal;
	int depthOfSearch;

//Start State
	Node * startNode;
// Goal State
	Node * goalNode;
// Current State
	Node * currentNode;
// Frontier of the A Star
	std::priority_queue<Node*, std::vector<Node*>, CompareClassNode> frontier;

// Successors
	std::vector<Node *> successors;
	std::vector<Node *> exploredSet;

//To calculate the number of nodes generated by the Search Algorithm
	int nodeCount;


// Functions
	/***
	 * Initializes the problem by using the start and goal state.
	 */
	void setInitStateGoalState(ProblemState &startState,
			ProblemState& goalState) {

		startNode = initializeNode();
		goalNode = initializeNode();

		startNode->currentState = startState;
		goalNode->currentState = goalState;

		currStateVal = STATE_SEARCHING;

		//Now Initialize the cost Values of the Nodes accordingly

		startNode->gCost = 0.0;
		startNode->hCost = startNode->currentState.heuristicsEstimate(
				goalNode->currentState);
		startNode->totalCost = startNode->gCost + startNode->hCost;
		startNode->Parent = NULL;

		//Now we update the frontier since we have explored the initial or goal node
		frontier.push(startNode);

		//Initialize the step count for how many steps you have taken
		countSteps = 0;
		depthOfSearch = 0;

	}

	/***
	 * Adding a successor node to the start or current Node while checking the frontier
	 */
	bool AddSuccessor(State &presentState){
		Node * newNode = initializeNode();
		if (!newNode) {
			return false;
		}
		newNode->currentState = presentState;
		successors.push_back(newNode);
		return true;
	}

	Node * initializeNode() {
		Node * newNode = new Node();
		nodeCount++;
		return newNode;
	}

	void deleteNode(Node * node) {
		nodeCount--;
		delete node;
	}
	/***
	 * Deleting the Nodes which are in frontier or exploredSet
	 */
	void deleteProcessedNodes(){
		//Delete frontier
		frontier = std::priority_queue<Node*, std::vector<Node*>, CompareClassNode>();
		//Delete the closeList of Nodes
		for( auto val : exploredSet){
					Node * temp = val;
					deleteNode(temp);
				}
		exploredSet.clear();
		//Delete the goal Node
		deleteNode(goalNode);
	}

	/***
	 * Deleting the Nodes which are not in frontier or exploredSet but generated using the successors
	 */
	void deleteUnProcessedNodes(){
		// Implement this function and check that you are having right things present
	}

	void initAsearch() {
		//Initial Conditions needs to be updated

	}

};

#endif /* ASEARCH_H_ */
